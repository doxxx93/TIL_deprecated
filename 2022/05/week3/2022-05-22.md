# 모던 자바 인 액션

## Chapter 6. 스트림으로 데이터 수집

`java.util.stream.Collectors`를 사용하게 된다.

### 6.1 컬렉터란 무엇인가?


### 6.2 리듀싱과 요약
https://junhyunny.blogspot.com/2019/04/collectors-reducing.html
https://junhyunny.blogspot.com/2019/04/stream-collect.html

#### 6.2.3 문자열 연결

https://junhyunny.blogspot.com/2019/04/collectors-joining.html


### 6.3 그룹화

`.collect(groupingBy(Function classifier, (Supplier mapFactory), (Collector downstream)))`

위와 같은 형태를 갖는다.

- groupingBy 팩토리 메서드는 인수를 1,2,3개를 갖게 오버로드하고있다.
  - classifier: 입력 요소를 키에 매핑하는 분류자 함수
  - mapFactory: 결과를 넣을 빈 Map을 제공하는 공급자.
  - downstream: 값을 리스트 외 다른 타입으로 반환하려면 이 인수를 명시해야 된다.

https://junhyunny.blogspot.com/2019/04/collectors-groupingby.html

```java
public final class Collectors {

    // 인수 1개를 갖는 경우: classifier(분류자)를 넣는다.
    // 인수를 두개 갖는 메서드를 리턴함
    public static <T, K> Collector<T, ?, Map<K, List<T>>>
    groupingBy(Function<? super T, ? extends K> classifier) {
        return groupingBy(classifier, toList());
    }

    // 인수 2개를 갖는 경우:
    public static <T, K, A, D>
    Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
        Collector<? super T, A, D> downstream) {
        return groupingBy(classifier, HashMap::new, downstream);
    }

    Collector<T, ?, M> groupingBy(Function<? super T, ? extends K> classifier,
        Supplier<M> mapFactory,
        Collector<? super T, A, D> downstream) {
        Supplier<A> downstreamSupplier = downstream.supplier();
        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
        BiConsumer<Map<K, A>, T> accumulator = (m, t) -> {
            K key = Objects.requireNonNull(classifier.apply(t),
                "element cannot be mapped to a null key");
            A container = m.computeIfAbsent(key, k -> downstreamSupplier.get());
            downstreamAccumulator.accept(container, t);
        };
        BinaryOperator<Map<K, A>> merger = Collectors.<K, A, Map<K, A>>mapMerger(
            downstream.combiner());
        @SuppressWarnings("unchecked")
        Supplier<Map<K, A>> mangledFactory = (Supplier<Map<K, A>>) mapFactory;

        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
            return new CollectorImpl<>(mangledFactory, accumulator, merger, CH_ID);
        } else {
            @SuppressWarnings("unchecked")
            Function<A, A> downstreamFinisher = (Function<A, A>) downstream.finisher();
            Function<Map<K, A>, M> finisher = intermediate -> {
                intermediate.replaceAll((k, v) -> downstreamFinisher.apply(v));
                @SuppressWarnings("unchecked")
                M castResult = (M) intermediate;
                return castResult;
            };
            return new CollectorImpl<>(mangledFactory, accumulator, merger, finisher, CH_NOID);
        }
    }
}
```

### 6.4 분할

`.collect(partitioningBy(Predicate predicate, (Collector downstream)))`

위와 같은 형태를 갖는다.

- partitioningBy 팩토리 메서드는 인수를 1,2,3개를 갖게 오버로드하고있다.
  - predicate: 뷴류 함수
  - downstream: 값을 리스트 외 다른 타입으로 반환하려면 이 인수를 명시해야 된다.
  -
https://junhyunny.blogspot.com/2019/04/collectors-partitioningby.html

```java
public final class Collectors {

    public static <T>
    Collector<T, ?, Map<Boolean, List<T>>> partitioningBy(Predicate<? super T> predicate) {
        return partitioningBy(predicate, toList());
    }

    public static <T, D, A>
    Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate,
        Collector<? super T, A, D> downstream) {
        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
        BiConsumer<Partition<A>, T> accumulator = (result, t) ->
            downstreamAccumulator.accept(predicate.test(t) ? result.forTrue : result.forFalse, t);
        BinaryOperator<A> op = downstream.combiner();
        BinaryOperator<Partition<A>> merger = (left, right) ->
            new Partition<>(op.apply(left.forTrue, right.forTrue),
                op.apply(left.forFalse, right.forFalse));
        Supplier<Partition<A>> supplier = () ->
            new Partition<>(downstream.supplier().get(),
                downstream.supplier().get());
        if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) {
            return new CollectorImpl<>(supplier, accumulator, merger, CH_ID);
        } else {
            Function<Partition<A>, Map<Boolean, D>> finisher = par ->
                new Partition<>(downstream.finisher().apply(par.forTrue),
                    downstream.finisher().apply(par.forFalse));
            return new CollectorImpl<>(supplier, accumulator, merger, finisher, CH_NOID);
        }
    }

}
```

### 6.5 Collector 인터페이스

https://junhyunny.blogspot.com/2019/04/collector-collectors.html

`toList` 구현

