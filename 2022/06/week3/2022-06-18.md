## Chapter 2. 입출금 내역 분석기

### 2.6 단일 책임 원칙

입출금 내역 분석기를 모듈화 할 수 있도록 확장

- CSV 파싱 로직을 새로운 클래스로 분리한다
- 도메인 클래스로 입출금 내역을 표현하는 클래스 생성
  - 다른 부분에서 입출금 내역 부분이라는 "의미"를 공유할 수 있다.

위 과정을 통해서 메인 응용프로그램에서 파싱 로직을 구현하는 부분을 없앴다

얻을 수 있는 효과

- 파싱 알고리즘 동작 방식을 변경해야 할 때도 한 클래스의 코드만 바꾸면 된다.
- 도메인 클래스 덕분에 다른 코드가 특정 데이터 형식에 의존하지 않게 되었다.

### 2.7 응집도

응집도는 서로 어떻게 관련되어 있는지의 척도

클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정한다.

#### 계산 연산 추출하기

전체 클래스를 의존하지 않고 계산 연산을 BankStatementProcessor라는 별도의 클래스로 추출한다.

#### 2.7.1 클래스 수준 응집도

- 실무에서의 그룹화
  - 기능: 한 개의 메서드를 갖는 클래스를 과도하게 만들 수 있음
  - 정보: 같은 데이터나 도메인 객체를 처리(CRUD)하는 메서드를 그룹화
    - 테이블이나 특정 도메인 객체를 저장하는 데이터베이스와 상호작용할 때 흔히 볼 수 있다
    - DAO라고 부르며 객체를 식별하는 일종의 ID가 필요하다
    - 여러 기능을 그룹화 하여 클래스 전체에 의존적이게 만들 수 있음
  - 유틸리티: 때로는 관련성 없는 메서드를 한 클래스로 포함 시켜야한다.
    - SRP원칙에 슬슬 어긋나기 시작한다.
  - 논리: 논리에 의해서 같은 클래스에 그룹화했지만 이는 한 클래스가 여러 책임을 갖게 만든다.
  - 순차: 여러 동작이 함께 수행되는지 쉽게 이해할 수 있지만 한 클래스를 바꿔야할 이유가 많아진다.
  - 시간: 각 동작을 이해하고 사용하기가 어렵다.

#### 2.7.2 메서드 수준 응집도

응집도가 낮은 메서드는 여러 책임을 포함하게 되기 때문에 if/else 블록을 많이 수반하게 된다.

응집도가 더 높은 조각으로 분리하는게 좋다.

### 2.8 결합도

한 기능이 다른 클래스에 얼마나 의존하고 있는지의 척도

코드가 서로 어떻게 의존하는지와 관련된 척도이다.

### 2.9 테스트

- 테스트를 하는 이유가 뭘까?
  - 코드가 항상 잘 동작하는지 어떻게 확신할 수 있을까?
  - 고객의 요구 사항을 충족했음을 무엇으로 보장할 수 있을까?

#### 2.9.1 테스트 자동화

- 확신
  - 테스트 규격 사양과 결과를 증거로 제공할 수있다.
- 변화에 대한 견고함
- 프로그램 이해도
  - 테스트는 다양한 컴포턴트의 의존성과 상호작용을 확인할 수 있다.

#### 2.9.2 JUnit 사용하기

- 유닛 테스트: 메서드, 클래스와 같은 작은 단위 테스트
  - BankStatementCSVParser 테스트 코드

#### 2.9.3 코드 커버리지

코드 커버리지: 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스틑 했는지의 척도

자코코, 에마, 코베르투라 같은 코드 커버리지 도구를 많이 사용한다.

구문 커버리지보단 분기 커버리지를 사용하는 것이 좋다.

### 2.10 총정리

- 2.5 에서 다룬 갓 클래스와 코드 중복은 코드 추론, 유지보수를 어렵게 만든다
- 2.6 에서 다룬 단일 책임 원칙(SRP)은 관리와 유지보수 하기 쉬운 코드 구현에 도움을 준다
- 2.7 에서 다룬 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다
- 2.8 에서 다룬 결합도는 클래스가 다른 코드 부분에 얼마나 의존하는지를 가리킨다
  - 높은 응집도, 낮은 결합도를 지향해라

### 2.11 되새김

- CSV 파서를 테스트하는 유닛 테스트를 몇 개 더 추가해보자
- 특정 날짜 범위에서 최대, 최소 거래 내역을 찾는 다양한 집계 연산을 추가해보자
- 월별, 성명별로 그룹화한 히스토그램을 반환해보자

### 2.12 도전 과제를 완료하며

- 요구 사항의 확장
- 제한적인 테스트 보완
- 버그 수정

3장에서 더 해보자