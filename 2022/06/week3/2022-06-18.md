## Chapter 2. 입출금 내역 분석기

### 2.6 단일 책임 원칙

입출금 내역 분석기를 모듈화 할 수 있도록 확장

- CSV 파싱 로직을 새로운 클래스로 분리한다
- 도메인 클래스로 입출금 내역을 표현하는 클래스 생성
  - 다른 부분에서 입출금 내역 부분이라는 "의미"를 공유할 수 있다.

위 과정을 통해서 메인 응용프로그램에서 파싱 로직을 구현하는 부분을 없앴다

얻을 수 있는 효과

- 파싱 알고리즘 동작 방식을 변경해야 할 때도 한 클래스의 코드만 바꾸면 된다.
- 도메인 클래스 덕분에 다른 코드가 특정 데이터 형식에 의존하지 않게 되었다.

### 2.7 응집도

응집도는 서로 어떻게 관련되어 있는지의 척도

클래스나 메서드의 책임이 서로 얼마나 강하게 연결되어 있는지를 측정한다.

#### 계산 연산 추출하기

전체 클래스를 의존하지 않고 계산 연산을 BankStatementProcessor라는 별도의 클래스로 추출한다.

#### 2.7.1 클래스 수준 응집도

- 실무에서의 그룹화
  - 기능: 한 개의 메서드를 갖는 클래스를 과도하게 만들 수 있음
  - 정보: 같은 데이터나 도메인 객체를 처리(CRUD)하는 메서드를 그룹화
    - 테이블이나 특정 도메인 객체를 저장하는 데이터베이스와 상호작용할 때 흔히 볼 수 있다
    - DAO라고 부르며 객체를 식별하는 일종의 ID가 필요하다
    - 여러 기능을 그룹화 하여 클래스 전체에 의존적이게 만들 수 있음
  - 유틸리티: 때로는 관련성 없는 메서드를 한 클래스로 포함 시켜야한다.
    - SRP원칙에 슬슬 어긋나기 시작한다.
  - 논리: 논리에 의해서 같은 클래스에 그룹화했지만 이는 한 클래스가 여러 책임을 갖게 만든다.
  - 순차: 여러 동작이 함께 수행되는지 쉽게 이해할 수 있지만 한 클래스를 바꿔야할 이유가 많아진다.
  - 시간: 각 동작을 이해하고 사용하기가 어렵다.

#### 2.7.2 메서드 수준 응집도

응집도가 낮은 메서드는 여러 책임을 포함하게 되기 때문에 if/else 블록을 많이 수반하게 된다.

응집도가 더 높은 조각으로 분리하는게 좋다.

### 2.8 결합도

한 기능이 다른 클래스에 얼마나 의존하고 있는지의 척도

코드가 서로 어떻게 의존하는지와 관련된 척도이다.

### 2.9 테스트

- 테스트를 하는 이유가 뭘까?
  - 코드가 항상 잘 동작하는지 어떻게 확신할 수 있을까?
  - 고객의 요구 사항을 충족했음을 무엇으로 보장할 수 있을까?

#### 2.9.1 테스트 자동화

- 확신
  - 테스트 규격 사양과 결과를 증거로 제공할 수있다.
- 변화에 대한 견고함
- 프로그램 이해도
  - 테스트는 다양한 컴포턴트의 의존성과 상호작용을 확인할 수 있다.

#### 2.9.2 JUnit 사용하기

- 유닛 테스트: 메서드, 클래스와 같은 작은 단위 테스트
  - BankStatementCSVParser 테스트 코드

#### 2.9.3 코드 커버리지

코드 커버리지: 테스트 집합이 소프트웨어의 소스코드를 얼마나 테스틑 했는지의 척도

자코코, 에마, 코베르투라 같은 코드 커버리지 도구를 많이 사용한다.

구문 커버리지보단 분기 커버리지를 사용하는 것이 좋다.

### 2.10 총정리

- 2.5 에서 다룬 갓 클래스와 코드 중복은 코드 추론, 유지보수를 어렵게 만든다
- 2.6 에서 다룬 단일 책임 원칙(SRP)은 관리와 유지보수 하기 쉬운 코드 구현에 도움을 준다
- 2.7 에서 다룬 응집도는 클래스나 메서드의 책임이 얼마나 강하게 연관되어 있는지를 가리킨다
- 2.8 에서 다룬 결합도는 클래스가 다른 코드 부분에 얼마나 의존하는지를 가리킨다
  - 높은 응집도, 낮은 결합도를 지향해라

### 2.11 되새김

- CSV 파서를 테스트하는 유닛 테스트를 몇 개 더 추가해보자
- 특정 날짜 범위에서 최대, 최소 거래 내역을 찾는 다양한 집계 연산을 추가해보자
- 월별, 성명별로 그룹화한 히스토그램을 반환해보자

### 2.12 도전 과제를 완료하며

- 요구 사항의 확장
- 제한적인 테스트 보완
- 버그 수정

3장에서 더 해보자

## Chapter 3. 입출금 내역 분석기 확장판

### 3.1 도전 과제

여러가지 개선할 예정이다

### 3.2 목표

다양한 종류의 입출금 내역 검색하고, 여러 포맷을 지원하고 처리하며 텍스트, HTML 등의 형식으로 리포트를 만들어 낼거다.

코드 유연성과 유지 보수성을 위한 개방/폐쇄 원칙(OCP)을 배운다

언제 인터페이스를 사용하는게 좋을지, 높은 결합도를 피하는 방법도 배운다

자바의 예외 처리 방법도 배운다

빌드 도구도 배운다

### 3.3 확장된 입출금 내역 분석기 요구 사항

- 특정 입출금 내역을 검색할 수 있는 기능
  - 주어진 날짜 범위 또는 특정 범주의 입출금 내역 얻기
- 검색 결과의 요약 통계를 텍스트, HTML 등 다양한 형식으로 만들기

### 3.4 개방/폐쇄 원칙

특정 금액 이상의 모든 입출금 내역을 검색하는 메서드를 구현한다

특정 월의 모든 입출금 내역을 검색하는 메서드를 구현한다

코드 중복 문제는 2장에서 다루었다

특정 월이나 금액으로 입출금 내역 검색하는 메서드를 구현한다

- 한계
  - 여러 속성을 조합할수록 코드가 점점 복잡해진다
  - 반복 로직과 비즈니스 로직이 결합되어 분리하기가 어려워진다
  - 코드 반복

인터페이스를 통해 이 문제를 해결한다

#### 3.4.1 함수형 인터페이스 인스턴스 만들기

Skip

어차피 람다식으로 해결할 수 있음

#### 3.4.2 람다 표현식

Skip

쓰잘데 없는 내용

### 3.5 인터페이스 문제

기존에 만들었던 메서드들이 처치곤란이다.

그렇다고 한 인터페이스에 모든 기능을 추가하는 갓 인터페이스를 만들면 안된다.

#### 3.5.1 갓 인터페이스

- 자바의 인터페이스는 모든 구현체가 지켜야 할 규칙을 정의한다. 즉 구현 클래스는 인터페이스에서 정의한 모든 연산의 구현 코드를 제공해야한다.
- 인터페이스가 도메인 객체의 특정 접근자에 종속적이면 안된다.

작은 인터페이스를 통하여 도메인 객체의 다양한 내부 연산으로 의존성을 최소화할 수 있다.

#### 3.5.2 지나친 세밀함

안티 응집도 문제가 발생한다

기능이 여러 인터페이스로 분산되므로 필요한 기능 찾기가 어렵다.

인터페이스가 너무 세밀하면 복잡도가 높아지며 새로운 인터페이스가 계속해서 추가된다.

### 3.6 명시적 API vs 암묵적 API

- 명시적 API 제공은 일반적(제너럴)인 용도의 메서드를 정의하는 것을 의미한다
  - 문서화를 잘 해두어야지 사용할 수 있다
  - 필요한 모든 상황을 단순한 API로 처리할 수 있다
- 암묵적 API 제공은 구체적으로 메서드를 정의하는 것을 의미한다
  - 메서드의 이름을 통해 어떤 동작을 수행하는지 알기 쉽다
  - 용도가 특정 상황에 국한되어 각 상황에 맞는 메서드를 많이 만들어야 하는 상황이 벌어진다

필요에 따라 알아서 잘 딱 센스있게 만들어라

#### 3.6.1 도메인 클래스 vs 원싯값

원싯값을 리턴하게 되면 다양한 결과를 반환할 수 없어서 유연성이 떨어진다

원싯값을 감싸는(래핑) 새 도메인 클래스를 만들어 이를 해결한다.

새 클래스에 필요한 필드와 결과를 추가하여 도메인의 다양한 개념간의 결합을 줄이고 유연성이 증가한다.

### 3.7 다양한 형식으로 내보내기

앞 내용과는 좀 다른 분위기

선택된 입출금 목록의 요약 통계를 텍스트, HTML, JSON

# 모던 자바 인 액션

## Chapter 9. 리팩터링, 테스팅, 디버깅

### 9.1 가독성과 유연성을 개선하는 리팩터링

#### 익명 클래스를 람다 표현식으로 리팩터링하기

- this와 super의 의미가 서로 다르다
  - 익명 클래스에서는 자신을, 람다에서는 람다를 감싸는 클래스를 가리킨다
- 익명 클래스는 클래스의 변수(shadow vairable)을 갖지만 람다는 안된다.
- 컨텍스트 오버로딩에 따른 모호함 발생
  - 인텔리제이가 해결해준다

#### 람다 표현식을 메서드 참조로 리팩터링하기

람다 표현식을 별도의 메서드로 추출 후 인수로 전달,

도메인 클래스에 메서드로 작성을 통해 메서드 참조로 변환 가능하다

연습 많이 해라

#### 명령형 데이터 처리를 스트림으로 리팩터링하기

킹론적으로 반복자를 이용한 컬렉션 처리 코드를 스트림으로 바꿔야한다

어려움

#### 코드 유연성 개선

- 동적 파리미터화
  - 함수형 인터페이스 적용
  - 조건부 연기 실행
    - 객체 상태가 클라이언트 코드로 노출되지 않는다
  - 실행 어라운드
    - 반복적으로 수행하는 코드가 있다면 람다로 변환

### 9.2 람다로 객체지향 디자인 패턴 리팩터링하기

#### 전략 패턴
