# 모던 자바 인 액션

## Chapter 9. 리팩터링, 테스팅, 디버깅

### 9.2 람다로 객체지향 디자인 패턴 리팩터링하기

#### 전략 패턴

#### 템플릿 메서드 패턴

#### 옵저버 패턴

#### 의무 체인 패턴

#### 팩토리 패턴

### 9.3 람다 테스팅

제대로 작동하는 코드를 구현하기 위함

#### 9.3.2 람다를 사용하는 메서드의 동작에 집중하라

assertj를 이용한 테스트 코드

```java
class DebuggingTest {

    @Test
    void testMoveAllPointsRightBy() {
        //given
        List<Point> points = Arrays.asList(new Point(5, 5), new Point(10, 5));
        List<Point> expectedPoints = Arrays.asList(new Point(15, 5), new Point(20, 5));
        //when
        List<Point> newPoints = Point.moveAllPointsRightBy(points, 10);

        //then
        assertThat(newPoints).usingRecursiveComparison().isEqualTo(expectedPoints);
    }
}
```

```java
public class UsingRecursiveComparison {


    public static void main(String[] args) {

        Person sherlock = new Person("Sherlock", 1.80);
        sherlock.home.ownedSince = new Date(123);

        sherlock.home.address.street = "Baker Street";
        sherlock.home.address.number = 221;

        Person sherlock2 = new Person("Sherlock", 1.80);
        sherlock2.home.ownedSince = new Date(123);

        sherlock2.home.address.street = "Baker Street";
        sherlock2.home.address.number = 221;

        // assertion succeeds as the data of both objects are the same.
        assertThat(sherlock).usingRecursiveComparison().isEqualTo(sherlock2);

        // assertion fails because sherlock.equals(sherlock2) is false.
        assertThat(sherlock).isEqualTo(sherlock2);
    }

    static class Person {

        String name;
        double height;
        Home home = new Home();
    }

    static class Home {

        Address address = new Address();
        Date ownedSince;
    }

    static class Address {

        int number;
        String street;
    }
}
```

#### 9.3.3 복잡한 람다를 개별 메서드로 분할하기

#### 9.3.4 고차원 함수 테스팅

이곳은 잘 모르겠다..


